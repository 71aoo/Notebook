# Thread In Java

### 前言

知道了Linux启动一个线程是使用函数 **pthread_create** ,那么它和 Java 的线程有什么联系呢？



### Thread In Java

#### 创建

```JAVA
public class ThreadExample {

    public static void createThread(){

        Thread t1 = new Thread() {

            @Override
            public void run() {

                System.out.println("I am a Java Thread");
            }
        };

        t1.start();
    }

    public static void main(String[] args) {

        createThread();
    }
}
```

Java创建一个线程主要有两种方式：

- 实现 **Runnable** 接口，实现接口中的**run方法**
- 继承 **Thread** 类，重写类中的**run方法**

可以看看到，两种方式，无论哪一种，都需要一个**run方法**，并且线程执行的主要逻辑全部都规定在run

方法实现，而且都调用了**start**去启动线程。



#### start0

![image-20200518165048135](.\NoteImg\image-20200518165048135.png)

**Thread** 中 **start** 方法调用的是 **native** 方法 **start0**。**start** 方法上面有一串黄色注释，拿来看看

```
This method is not invoked for the main method thread or "system" group,threads created/set up by the VM

主方法线程或“系统”组不会调用此方法,线程由JVM创建/设置。
```

通过这句话，可以得知 **start0** 方法在 **Jvm（Hotspot）**中。通过 **Jvm** 来调度创建该线程。

在 **JVM** 找到该方法

```C++
static JNINativeMethod methods[] = {
    {"start0",           "()V",        (void *)&JVM_StartThread},
    {"stop0",            "(" OBJ ")V", (void *)&JVM_StopThread},
    {"isAlive",          "()Z",        (void *)&JVM_IsThreadAlive},
    {"suspend0",         "()V",        (void *)&JVM_SuspendThread},
    {"resume0",          "()V",        (void *)&JVM_ResumeThread},
    {"setPriority0",     "(I)V",       (void *)&JVM_SetThreadPriority},
    {"yield",            "()V",        (void *)&JVM_Yield},
    {"sleep",            "(J)V",       (void *)&JVM_Sleep},
    {"currentThread",    "()" THD,     (void *)&JVM_CurrentThread},
    {"countStackFrames", "()I",        (void *)&JVM_CountStackFrames},
    {"interrupt0",       "()V",        (void *)&JVM_Interrupt},
    {"isInterrupted",    "(Z)Z",       (void *)&JVM_IsInterrupted},
    {"holdsLock",        "(" OBJ ")Z", (void *)&JVM_HoldsLock},
    {"getThreads",        "()[" THD,   (void *)&JVM_GetAllThreads},
    {"dumpThreads",      "([" THD ")[[" STE, (void *)&JVM_DumpThreads},
};
```

进入 **JVM_StartThread** 方法

```java
JVM_ENTRY(void, JVM_StartThread(JNIEnv* env, jobject jthread))
  JVMWrapper("JVM_StartThread");
  JavaThread *native_thread = NULL;
  bool throw_illegal_thread_state = false;
  {
	.....
    native_thread = new JavaThread(&thread_entry, sz);
	.....
  }
```

继续 **JavaThread**

```c++
JavaThread::JavaThread(ThreadFunction entry_point, size_t stack_sz) :
  Thread()
#if INCLUDE_ALL_GCS
  , _satb_mark_queue(&_satb_mark_queue_set),
  _dirty_card_queue(&_dirty_card_queue_set)
#endif // INCLUDE_ALL_GCS
{
  .....
  os::create_thread(this, thr_type, stack_sz);

}
```

还有继续 **create_thread**

```c++
bool os::create_thread(Thread* thread, ThreadType thr_type, size_t stack_size) {
  assert(thread->osthread() == NULL, "caller responsible");

    pthread_t tid;
    int ret = pthread_create(&tid, &attr, (void* (*)(void*)) java_start, thread);
 
}
```

终于可以看到 **pthread_create** 函数，创建线程，执行的是 **Java_start** 方法。

既然Java底层创建线程是调用 **pthread_creadte** 函数来创建线程，再结合 Java 线程实现特点以及 **pthread_creadte** 函数的参数，不难推断出，**JVM 中 Java_start 方法就是 Java中 Thread 类的 run 方法**。



### 手动实现

了解原来后，模仿一下J **JVM** 的实现



#### JNI调用

**JNI调用**，使用这技术，实现 **Java** 中调用 **native** 方法

**MyThread.java**

```java
public class MyThread {

    /**
     * 装载动态链接库
     */
    static {
        System.loadLibrary("MyThreadNative");
    }

    /**
     * 自定义 native 方法
     */
    private native void start0();

    public static void main(String[] args) {

        MyThread myThread = new MyThread();
        myThread.start0();
    }
    
}
```

编译 

```shell
javac MyThread.java		//编译成class
Javah MyThread			//编译成头文件
```

![image-20200518202320142](.\NoteImg\image-20200518202320142.png)

**MyThread.h**

```c++
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class MyThread */

#ifndef _Included_MyThread
#define _Included_MyThread
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     MyThread
 * Method:    start0
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_MyThread_start0
  (JNIEnv *, jobject);

#ifdef __cplusplus
}
#endif
#endif
```

可以看到 **Java_MyThread_start0** 就是我们调用的方法。

**MyThread.c**

```c
#include <pthread.h>		//线程头文件
#include <stdio.h>
#include "MyThread.h"

//定义接受线程id的变量
pthread_t pid;

//定义线程主体函数
void* thread_entity(void *arg){
    
    int i;
    
    for(i = 0; i < 100, i++){
        printf("new thread: %d\n",i);
    }
}

/*
 * env JVM虚拟机
 */
JNIEXPORT void JNICALL Java_MyThread_start0
 (JNIEnv *env, jobject c1){
   
    int i;
    
    //调用pthread_create创建一个线程
    pthread_create(&pid, NULL, thread_entity, NULL);
    
    for(i = 0; i < 100, i++){
        printf("main thread: %d\n",i);
    }
    
}

int main(){
    
    return 0;
}

```

把**MyThread.c** 编译成动态链接库

```shell
gcc ‐fPIC ‐I $JAVA_HOM/include -I $JAVA_HOM/include/linux ‐shared ‐o libMyThreadNative.so MyThread.c
```

注意名字生成的so文件命名规则为 **libxx.so** xx为再 java 代码中的装库名

```java
static {
    System.loadLibrary("MyThreadNative");
}
```

![image-20200518211127095](.\NoteImg\image-20200518211127095.png)

运行测试

```shell
java -Djava.library.path=/home/ MyThread
```

![image-20200518211353264](.\NoteImg\image-20200518211353264.png)

成功运行，线程交错打印

#### JNI反向调用

虽然实现调用 **native** 方法，并使用C语言调用系统函数创建线程，但是线程主体是在C语言实现的，而Java是调用的 **Thread** 类的 **run** 方法。因此，为了反调用J **run** 方法，本文使用 **JNI反向调用** 技术（Java8 中并不是使用这一技术）

在 **MyThread.c** 修改调用 **thread_entity** 方法

```c
#include <pthread.h>		//线程头文件
#include <stdio.h>
#include "MyThread.h"

JavaVM *jvm = NULL;
jobject c2 = NULL;

//定义接受线程id的变量
pthread_t pid;

//定义线程主体函数
void* thread_entity(void *arg){
    
    JNIEnv *env; 
    jclass cls;
    jmethodID rid;
   	jint ret = 0;
    
    //Attach主线程  
    if((*jvm)->AttachCurrentThread(jvm, &env, NULL) != JNI_OK)  
    {  
        printf("erorr\n");
        return NULL;  
    }  

    //获取java类 
    cls = (*env)->GetObjectClass(env,c2);
    if(cls==NULL){

    	printf("find Class error!\n");
    	return;
    }
    
    //获取java的run方法
    rid =(*env)->GetMethodID(env,cls,"run","()V");
    if(rid==NULL){
        printf("find constructor error!\n");
        return;
    }

    //回调方法
    ret = (*env)->CallIntMethod(env,job,rid,NULL);

    //Detach主线程  
    if((*jvm)->DetachCurrentThread(jvm) != JNI_OK)  
    {  
        printf("erorr\n");
        return NULL;  
    }  
    
    //退出线程
    pthread_exit(0);
}

/*
 * env JVM虚拟机
 */
JNIEXPORT void JNICALL Java_MyThread_start0
 (JNIEnv *env, jobject c1){
    
    //通过JavaVM来得到当前线程的JNIEnv指针. 
    (*env)->GetJavaVM(env,&jvm);
    
    //将c1保持到全局变量中
    c2 = (*env)->NewGlobalRef(env,c1);
    
    //调用pthread_create创建一个线程
    pthread_create(&pid, NULL, thread_entity, NULL);
    
}

int main(){
    
    return 0;
}
```

重新编译

```shell
gcc ‐fPIC ‐I $JAVA_HOM/include -I $JAVA_HOM/include/linux ‐shared ‐o libMyThreadNative.so MyThread.c
```

执行

```shell
java -Djava.library.path=/home/ MyThread
```

![image-20200519154032500](.\NoteImg\image-20200519154032500.png)

可以看到主线程和子线程交替执行。

### 总结

牛逼！！！自己动手实现Java多线程，可以简单了解 **JVM** 是是如何调度系统函数创建和运行一个线程。虽然**JVM** 可能并不是这样做的。



这里 **MyThread.c** 在调用 **MyThead** 类的 **run** 方法再去执行是否觉得有点像Java中的反射，这是不是 **Java反射** 在**JVM**上的实现机制呢？（我也不知道）



### 参考文章

- [从 Java 到 C++, 以 JVM 的角度看 Java 线程的创建与运行](https://juejin.im/entry/593fce1c128fe1006a01f15e)